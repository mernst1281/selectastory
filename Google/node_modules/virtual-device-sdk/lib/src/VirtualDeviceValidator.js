"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const https = require("https");
const VirtualDevice_1 = require("./VirtualDevice");
exports.VirtualDeviceScriptUnauthorizedError = new Error("Security token lacks sufficient " +
    "information. Please re-authenticate with Amazon here to update your security token.");
exports.VirtualDeviceValidatorUnauthorizedMessage = (invocationName) => {
    return "Security token lacks sufficient " +
        `permissions to invoke "${invocationName}" skill.<br><br>` +
        "To correct this, make sure in the " +
        `<a href="https://developer.amazon.com/edw/home.html#/" target="_blank">` +
        "Alexa developer console</a> that the skill is associated with your account.<br><br>" +
        "If you are still having issues, contact us " +
        `<a href="mailto:support@bespoken.io">support@bespoken.io</a>.`;
};
class VirtualDeviceValidator {
    constructor(token, userID, baseURL, sourceAPIBaseURL) {
        this.virtualDevice = new VirtualDevice_1.VirtualDevice(token);
        this.virtualDevice.baseURL = baseURL ? baseURL : "https://virtual-device.bespoken.io/process";
        this.subscribers = { message: [], result: [], unauthorized: [] };
        this.sourceAPIBaseURL = sourceAPIBaseURL ? sourceAPIBaseURL : "https://source-api.bespoken.tools";
        this.userID = userID;
    }
    subscribe(event, cb) {
        if (event in this.subscribers) {
            this.subscribers[event].push(cb);
        }
    }
    unsubscribe(event) {
        this.subscribers[event] = [];
    }
    execute(virtualDeviceTestSequences, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = { tests: [] };
            const totalSequences = virtualDeviceTestSequences.length;
            let currentSequenceIndex = 0;
            for (const sequence of virtualDeviceTestSequences) {
                let checkAuthResult;
                try {
                    checkAuthResult = yield this.checkAuth(sequence.invocationName);
                }
                catch (err) {
                    this.emit("unauthorized", exports.VirtualDeviceScriptUnauthorizedError, undefined, context);
                    return Promise.reject(err);
                }
                if (checkAuthResult !== "AUTHORIZED") {
                    this.emit("unauthorized", exports.VirtualDeviceScriptUnauthorizedError, undefined, context);
                    return Promise.reject(exports.VirtualDeviceScriptUnauthorizedError);
                }
                currentSequenceIndex += 1;
                if (currentSequenceIndex === 1) {
                    yield this.virtualDevice.resetSession();
                }
                for (const test of sequence.tests) {
                    try {
                        const resultItem = { test };
                        resultItem.status = "running";
                        const validator = new Validator(resultItem, undefined);
                        this.emit("message", undefined, validator.resultItem, context);
                        const actual = yield this.virtualDevice.message(test.input);
                        resultItem.actual = actual;
                        if (validator.resultItem && validator.check()) {
                            validator.resultItem.result = "success";
                        }
                        else {
                            validator.resultItem.result = "failure";
                        }
                        validator.resultItem.status = "done";
                        result.tests.push(validator.resultItem);
                        this.emit("result", undefined, validator.resultItem, context);
                    }
                    catch (err) {
                        const resultItem = { test };
                        const validator = new Validator(resultItem, err);
                        validator.resultItem.result = "failure";
                        validator.resultItem.status = "done";
                        result.tests.push(validator.resultItem);
                        this.emit("result", undefined, validator.resultItem, context);
                    }
                }
                if (totalSequences > currentSequenceIndex) {
                    yield this.virtualDevice.message("Alexa, exit");
                }
            }
            const failures = result.tests.filter((test) => test.result === "failure");
            if (failures && failures.length > 0) {
                result.result = "failure";
            }
            else {
                result.result = "success";
            }
            return Promise.resolve(result);
        });
    }
    checkAuth(invocationName) {
        return new Promise((resolve, reject) => {
            let data = "";
            const params = `?invocation_name=${invocationName}` +
                `&user_id=${this.userID}`;
            const url = this.sourceAPIBaseURL + "/v1/skillAuthorized" + params;
            const req = https.get(url, (res) => {
                res.on("data", (chunk) => {
                    data += chunk;
                });
                res.on("end", () => {
                    if (res.statusCode === 200 && data === "AUTHORIZED") {
                        resolve(data);
                    }
                    else {
                        reject(exports.VirtualDeviceValidatorUnauthorizedMessage(invocationName));
                    }
                });
            });
            req.on("error", function (error) {
                reject(error.message);
            });
            req.end();
        });
    }
    emit(event, error, data, context) {
        if (event in this.subscribers) {
            this.subscribers[event].forEach((subscriber) => {
                subscriber(error, data, context);
            });
        }
    }
}
exports.VirtualDeviceValidator = VirtualDeviceValidator;
class Validator {
    constructor(resultItem, error) {
        this.resultItem = resultItem;
        this.error = error;
    }
    check() {
        if (this.error) {
            return false;
        }
        if (this.resultItem.test.comparison !== "contains") {
            return false;
        }
        if (!this.resultItem.test.expectedTranscript &&
            !this.resultItem.test.expectedStreamURL) {
            return true;
        }
        if (this.resultItem.test.expectedTranscript === "*"
            || this.resultItem.test.expectedStreamURL === "*"
            || this.resultItem.test.expectedTranscript === ""
            || this.resultItem.test.expectedStreamURL === "") {
            return true;
        }
        if (this.resultItem.actual &&
            this.resultItem.actual.transcript &&
            this.resultItem.test.expectedTranscript &&
            this.resultItem.test.comparison === "contains" &&
            this.resultItem.actual.transcript.includes(this.resultItem.test.expectedTranscript)) {
            return true;
        }
        return !!(this.resultItem.actual &&
            this.resultItem.actual.streamURL &&
            this.resultItem.test.expectedStreamURL &&
            this.resultItem.test.comparison === "contains" &&
            this.resultItem.actual.streamURL.includes(this.resultItem.test.expectedStreamURL));
    }
}
exports.Validator = Validator;
//# sourceMappingURL=VirtualDeviceValidator.js.map